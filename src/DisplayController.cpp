#include "DisplayController.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "utils.h"

// I2C instance (defined here, not in header, to avoid SDK header dependency)
#define DISPLAY_I2C i2c1

extern const char* const PROGRAMMER_VERSION;

// 8x8 font for ASCII 32-126 (95 characters, 760 bytes)
// Row-based format: 8 bytes per char, each byte = one row, bit 0 = leftmost pixel.
// Based on font8x8_basic by Marcel Sondaar (public domain).
// Bolder than a 6x8 font — vertical strokes are 2px wide.
static const uint8_t font_8x8[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 32: Space
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // 33: !
    {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 34: "
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}, // 35: #
    {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00}, // 36: $
    {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00}, // 37: %
    {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00}, // 38: &
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // 39: '
    {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00}, // 40: (
    {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00}, // 41: )
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // 42: *
    {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00}, // 43: +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06}, // 44: ,
    {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00}, // 45: -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // 46: .
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}, // 47: /
    {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00}, // 48: 0
    {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00}, // 49: 1
    {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00}, // 50: 2
    {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00}, // 51: 3
    {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00}, // 52: 4
    {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00}, // 53: 5
    {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00}, // 54: 6
    {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00}, // 55: 7
    {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00}, // 56: 8
    {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00}, // 57: 9
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // 58: :
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06}, // 59: ;
    {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00}, // 60: <
    {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00}, // 61: =
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00}, // 62: >
    {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00}, // 63: ?
    {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00}, // 64: @
    {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00}, // 65: A
    {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00}, // 66: B
    {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00}, // 67: C
    {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00}, // 68: D
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00}, // 69: E
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00}, // 70: F
    {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00}, // 71: G
    {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00}, // 72: H
    {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 73: I
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00}, // 74: J
    {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00}, // 75: K
    {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00}, // 76: L
    {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00}, // 77: M
    {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00}, // 78: N
    {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00}, // 79: O
    {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00}, // 80: P
    {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00}, // 81: Q
    {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00}, // 82: R
    {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00}, // 83: S
    {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 84: T
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00}, // 85: U
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // 86: V
    {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // 87: W
    {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00}, // 88: X
    {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00}, // 89: Y
    {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00}, // 90: Z
    {0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00}, // 91: [
    {0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00}, // 92: backslash
    {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00}, // 93: ]
    {0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00}, // 94: ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // 95: _
    {0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // 96: `
    {0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00}, // 97: a
    {0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00}, // 98: b
    {0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00}, // 99: c
    {0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00}, // 100: d
    {0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00}, // 101: e
    {0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00}, // 102: f
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F}, // 103: g
    {0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00}, // 104: h
    {0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 105: i
    {0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E}, // 106: j
    {0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00}, // 107: k
    {0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 108: l
    {0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00}, // 109: m
    {0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00}, // 110: n
    {0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00}, // 111: o
    {0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F}, // 112: p
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78}, // 113: q
    {0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00}, // 114: r
    {0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00}, // 115: s
    {0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00}, // 116: t
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00}, // 117: u
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // 118: v
    {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00}, // 119: w
    {0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00}, // 120: x
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F}, // 121: y
    {0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00}, // 122: z
    {0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00}, // 123: {
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // 124: |
    {0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00}, // 125: }
    {0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 126: ~
};

// Transpose one row-based glyph column to a vertical byte for the framebuffer.
// col = which column (0-7), glyph = pointer to 8 row bytes.
static inline uint8_t transposeColumn(const uint8_t* glyph, int col) {
    uint8_t column_byte = 0;
    for (int row = 0; row < 8; row++) {
        if (glyph[row] & (1 << col))
            column_byte |= (1 << row);
    }
    return column_byte;
}

// SSD1306 init commands for 128x32
static const uint8_t ssd1306_init_cmds[] = {
    0xAE,       // Display off
    0xD5, 0x80, // Set display clock divide ratio
    0xA8, 0x1F, // Set multiplex ratio (32-1)
    0xD3, 0x00, // Set display offset = 0
    0x40,       // Set start line = 0
    0x8D, 0x14, // Enable charge pump
    0x20, 0x00, // Horizontal addressing mode
    0xA1,       // Segment remap (normal, will be set by flip)
    0xC8,       // COM scan direction (normal, will be set by flip)
    0xDA, 0x02, // COM pins hardware config (sequential, for 128x32)
    0x81, 0x8F, // Set contrast
    0xD9, 0xF1, // Set pre-charge period
    0xDB, 0x40, // Set VCOMH deselect level
    0xA4,       // Entire display ON (follow RAM)
    0xA6,       // Normal display (not inverted)
    0xAF,       // Display on
};

DisplayController::DisplayController()
    : display_present(false), needs_redraw(false), is_flipped(false),
      is_sleeping(false), last_activity_ms(0) {
    memset(framebuffer, 0, sizeof(framebuffer));
    menu_line[0] = '\0';
    state_line[0] = '\0';
    info_line[0] = '\0';
}

DisplayController::~DisplayController() {
}

bool DisplayController::probe() {
    // Try to write a single command byte; if NACK, no display
    uint8_t buf[2] = { 0x00, 0xAE };  // command prefix + display off
    int ret = i2c_write_timeout_us(DISPLAY_I2C, DISPLAY_ADDR, buf, 2, false, 50000);
    return ret == 2;
}

void DisplayController::sendCommand(uint8_t cmd) {
    uint8_t buf[2] = { 0x00, cmd };
    i2c_write_timeout_us(DISPLAY_I2C, DISPLAY_ADDR, buf, 2, false, 50000);
}

void DisplayController::sendCommands(const uint8_t* cmds, size_t len) {
    for (size_t i = 0; i < len; i++) {
        sendCommand(cmds[i]);
    }
}

void DisplayController::initDisplay(bool flipped) {
    sendCommands(ssd1306_init_cmds, sizeof(ssd1306_init_cmds));

    // Apply flip setting
    is_flipped = flipped;
    sendCommand(flipped ? 0xA0 : 0xA1);  // SEG_REMAP
    sendCommand(flipped ? 0xC0 : 0xC8);  // COM_SCAN_DIR
}

void DisplayController::init(bool flipped) {
    // Initialize I2C1
    i2c_init(DISPLAY_I2C, DISPLAY_I2C_FREQ);
    gpio_set_function(DISPLAY_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(DISPLAY_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(DISPLAY_SDA_PIN);
    gpio_pull_up(DISPLAY_SCL_PIN);

    // Probe for display
    if (!probe()) {
        display_present = false;
        printf_g("// WARNING: No display detected on I2C1 (0x%02X)\n", DISPLAY_ADDR);
        return;
    }

    display_present = true;
    printf_g("// Display detected on I2C1 (0x%02X)\n", DISPLAY_ADDR);

    initDisplay(flipped);
    last_activity_ms = to_ms_since_boot(get_absolute_time());

    // Initial content
    snprintf(info_line, sizeof(info_line), "PewPewCH32 %s", PROGRAMMER_VERSION);

    needs_redraw = true;
}

void DisplayController::flush() {
    if (!display_present) return;

    // Set column and page address to cover full display
    sendCommand(0x21); sendCommand(0); sendCommand(127);  // Column range
    sendCommand(0x22); sendCommand(0); sendCommand(DISPLAY_PAGES - 1);  // Page range

    // Send framebuffer as data in chunks
    static const int CHUNK = 128;
    for (int offset = 0; offset < DISPLAY_BUF_SIZE; offset += CHUNK) {
        int len = DISPLAY_BUF_SIZE - offset;
        if (len > CHUNK) len = CHUNK;

        uint8_t buf[CHUNK + 1];
        buf[0] = 0x40;  // data prefix
        memcpy(buf + 1, framebuffer + offset, len);
        i2c_write_timeout_us(DISPLAY_I2C, DISPLAY_ADDR, buf, len + 1, false, 100000);
    }
}

void DisplayController::clear() {
    memset(framebuffer, 0, sizeof(framebuffer));
}

void DisplayController::drawString(int x, int y, const char* str) {
    assert((y % 8) == 0);  // Must be page-aligned
    int page = y / 8;
    if (page >= DISPLAY_PAGES) return;
    int cx = x;
    while (*str) {
        if (cx + FONT_WIDTH > DISPLAY_WIDTH) break;
        char c = *str;
        if (c < 32 || c > 126) c = '?';
        const uint8_t* glyph = font_8x8[c - 32];
        for (int col = 0; col < FONT_WIDTH; col++) {
            framebuffer[page * DISPLAY_WIDTH + cx + col] |= transposeColumn(glyph, col);
        }
        cx += FONT_WIDTH;
        str++;
    }
}

void DisplayController::drawStringInverted(int x, int y, const char* str) {
    assert((y % 8) == 0);  // Must be page-aligned
    int page = y / 8;
    if (page >= DISPLAY_PAGES) return;
    memset(framebuffer + page * DISPLAY_WIDTH, 0xFF, DISPLAY_WIDTH);

    int cx = x;
    while (*str) {
        if (cx + FONT_WIDTH > DISPLAY_WIDTH) break;
        char c = *str;
        if (c < 32 || c > 126) { cx += FONT_WIDTH; str++; continue; }
        const uint8_t* glyph = font_8x8[c - 32];
        for (int col = 0; col < FONT_WIDTH; col++) {
            framebuffer[page * DISPLAY_WIDTH + cx + col] = ~(transposeColumn(glyph, col) << 1);
        }
        cx += FONT_WIDTH;
        str++;
    }
}

void DisplayController::drawStringPixel(int x, int y, const char* str) {
    int page = y / 8;
    int bit_offset = y % 8;
    int cx = x;
    while (*str) {
        if (cx + FONT_WIDTH > DISPLAY_WIDTH) break;
        char c = *str;
        if (c < 32 || c > 126) c = '?';
        const uint8_t* glyph = font_8x8[c - 32];
        for (int col = 0; col < FONT_WIDTH; col++) {
            uint8_t col_byte = transposeColumn(glyph, col);
            if (page < DISPLAY_PAGES)
                framebuffer[page * DISPLAY_WIDTH + cx + col] |= (col_byte << bit_offset);
            if (bit_offset > 0 && (page + 1) < DISPLAY_PAGES)
                framebuffer[(page + 1) * DISPLAY_WIDTH + cx + col] |= (col_byte >> (8 - bit_offset));
        }
        cx += FONT_WIDTH;
        str++;
    }
}

void DisplayController::render() {
    clear();

    // Line 0 (y=0): Selected menu entry — inverted, centered
    if (menu_line[0]) {
        int text_width = strlen(menu_line) * FONT_WIDTH;
        int x = (DISPLAY_WIDTH - text_width) / 2;
        if (x < 0) x = 0;
        drawStringInverted(x, 0, menu_line);
    }

    // Filled pixel row below menu bar (y=8)
    memset(framebuffer + 1 * DISPLAY_WIDTH, 0x01, DISPLAY_WIDTH);

    // Line 2 (y=13): System state
    if (state_line[0]) {
        drawStringPixel(0, 13, state_line);
    }

    // Line 3 (y=24): Version / contextual info
    if (info_line[0]) {
        drawString(0, 24, info_line);
    }

    flush();
}

void DisplayController::update() {
    if (!display_present) return;

    // Screensaver: blank after inactivity
    if (!is_sleeping) {
        uint32_t now = to_ms_since_boot(get_absolute_time());
        if ((now - last_activity_ms) >= DISPLAY_SLEEP_MS) {
            sendCommand(0xAE);  // Display off
            is_sleeping = true;
            return;
        }
    }

    if (!needs_redraw) return;
    needs_redraw = false;
    render();
}

void DisplayController::wake() {
    last_activity_ms = to_ms_since_boot(get_absolute_time());
    if (is_sleeping && display_present) {
        sendCommand(0xAF);  // Display on
        is_sleeping = false;
        needs_redraw = true;
    }
}

void DisplayController::setMenuEntry(const char* name) {
    wake();
    snprintf(menu_line, sizeof(menu_line), "%s", name);
    needs_redraw = true;
}

void DisplayController::setSystemState(SystemState state) {
    wake();
    snprintf(state_line, sizeof(state_line), "%s", StateMachine::getStateName(state));

    switch (state) {
        case STATE_CHECKING_TARGET:
            snprintf(info_line, sizeof(info_line), "Detect target");
            break;
        case STATE_PROGRAMMING:
            snprintf(info_line, sizeof(info_line), "Don't unplug!");
            break;
        case STATE_SUCCESS:
            snprintf(info_line, sizeof(info_line), "Verified OK");
            break;
        case STATE_ERROR:
            snprintf(info_line, sizeof(info_line), "Check cable!");
            break;
        default:
            snprintf(info_line, sizeof(info_line), "PewPewCH32 %s", PROGRAMMER_VERSION);
            break;
    }
    needs_redraw = true;
}

void DisplayController::setFlipped(bool flipped) {
    is_flipped = flipped;
    if (!display_present) return;
    wake();
    sendCommand(flipped ? 0xA0 : 0xA1);  // SEG_REMAP
    sendCommand(flipped ? 0xC0 : 0xC8);  // COM_SCAN_DIR
    needs_redraw = true;
}
